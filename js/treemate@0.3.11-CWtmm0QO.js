function I(e){return Array.isArray(e)?e:[e]}const G={STOP:"STOP"};function M(e,t){const n=t(e);e.children!==void 0&&n!==G.STOP&&e.children.forEach(r=>M(r,t))}function F(e,t={}){const{preserveGroup:n=!1}=t,r=[],s=n?i=>{i.isLeaf||(r.push(i.key),d(i.children))}:i=>{i.isLeaf||(i.isGroup||r.push(i.key),d(i.children))};function d(i){i.forEach(s)}return d(e),r}function R(e,t){const{isLeaf:n}=e;return n!==void 0?n:!t(e)}function j(e){return e.children}function U(e){return e.key}function q(){return!1}function V(e,t){const{isLeaf:n}=e;return!(n===!1&&!Array.isArray(t(e)))}function W(e){return e.disabled===!0}function Z(e,t){return e.isLeaf===!1&&!Array.isArray(t(e))}function P(e){var t;return e==null?[]:Array.isArray(e)?e:(t=e.checkedKeys)!==null&&t!==void 0?t:[]}function x(e){var t;return e==null||Array.isArray(e)?[]:(t=e.indeterminateKeys)!==null&&t!==void 0?t:[]}function z(e,t){const n=new Set(e);return t.forEach(r=>{n.has(r)||n.add(r)}),Array.from(n)}function B(e,t){const n=new Set(e);return t.forEach(r=>{n.has(r)&&n.delete(r)}),Array.from(n)}function H(e){return(e==null?void 0:e.type)==="group"}function ae(e){const t=new Map;return e.forEach((n,r)=>{t.set(n.key,r)}),n=>{var r;return(r=t.get(n))!==null&&r!==void 0?r:null}}class J extends Error{constructor(){super(),this.message="SubtreeNotLoadedError: checking a subtree whose required nodes are not fully loaded."}}function Q(e,t,n,r){return C(t.concat(e),n,r,!1)}function X(e,t){const n=new Set;return e.forEach(r=>{const s=t.treeNodeMap.get(r);if(s!==void 0){let d=s.parent;for(;d!==null&&!(d.disabled||n.has(d.key));)n.add(d.key),d=d.parent}}),n}function Y(e,t,n,r){const s=C(t,n,r,!1),d=C(e,n,r,!0),i=X(e,n),c=[];return s.forEach(o=>{(d.has(o)||i.has(o))&&c.push(o)}),c.forEach(o=>s.delete(o)),s}function E(e,t){const{checkedKeys:n,keysToCheck:r,keysToUncheck:s,indeterminateKeys:d,cascade:i,leafOnly:c,checkStrategy:o,allowNotLoaded:l}=e;if(!i)return r!==void 0?{checkedKeys:z(n,r),indeterminateKeys:Array.from(d)}:s!==void 0?{checkedKeys:B(n,s),indeterminateKeys:Array.from(d)}:{checkedKeys:Array.from(n),indeterminateKeys:Array.from(d)};const{levelTreeNodeMap:h}=t;let f;s!==void 0?f=Y(s,n,t,l):r!==void 0?f=Q(r,n,t,l):f=C(n,t,l,!1);const m=o==="parent",w=o==="child"||c,g=f,N=new Set,v=Math.max.apply(null,Array.from(h.keys()));for(let A=v;A>=0;A-=1){const L=A===0,b=h.get(A);for(const u of b){if(u.isLeaf)continue;const{key:a,shallowLoaded:p}=u;if(w&&p&&u.children.forEach(y=>{!y.disabled&&!y.isLeaf&&y.shallowLoaded&&g.has(y.key)&&g.delete(y.key)}),u.disabled||!p)continue;let K=!0,k=!1,S=!0;for(const y of u.children){const O=y.key;if(!y.disabled){if(S&&(S=!1),g.has(O))k=!0;else if(N.has(O)){k=!0,K=!1;break}else if(K=!1,k)break}}K&&!S?(m&&u.children.forEach(y=>{!y.disabled&&g.has(y.key)&&g.delete(y.key)}),g.add(a)):k&&N.add(a),L&&w&&g.has(a)&&g.delete(a)}}return{checkedKeys:Array.from(g),indeterminateKeys:Array.from(N)}}function C(e,t,n,r){const{treeNodeMap:s,getChildren:d}=t,i=new Set,c=new Set(e);return e.forEach(o=>{const l=s.get(o);l!==void 0&&M(l,h=>{if(h.disabled)return G.STOP;const{key:f}=h;if(!i.has(f)&&(i.add(f),c.add(f),Z(h.rawNode,d))){if(r)return G.STOP;if(!n)throw new J}})}),c}function $(e,{includeGroup:t=!1,includeSelf:n=!0},r){var s;const d=r.treeNodeMap;let i=e==null?null:(s=d.get(e))!==null&&s!==void 0?s:null;const c={keyPath:[],treeNodePath:[],treeNode:i};if(i!=null&&i.ignored)return c.treeNode=null,c;for(;i;)!i.ignored&&(t||!i.isGroup)&&c.treeNodePath.push(i),i=i.parent;return c.treeNodePath.reverse(),n||c.treeNodePath.pop(),c.keyPath=c.treeNodePath.map(o=>o.key),c}function ee(e){if(e.length===0)return null;const t=e[0];return t.isGroup||t.ignored||t.disabled?t.getNext():t}function ne(e,t){const n=e.siblings,r=n.length,{index:s}=e;return t?n[(s+1)%r]:s===n.length-1?null:n[s+1]}function _(e,t,{loop:n=!1,includeDisabled:r=!1}={}){const s=t==="prev"?te:ne,d={reverse:t==="prev"};let i=!1,c=null;function o(l){if(l!==null){if(l===e){if(!i)i=!0;else if(!e.disabled&&!e.isGroup){c=e;return}}else if((!l.disabled||r)&&!l.ignored&&!l.isGroup){c=l;return}if(l.isGroup){const h=T(l,d);h!==null?c=h:o(s(l,n))}else{const h=s(l,!1);if(h!==null)o(h);else{const f=re(l);f!=null&&f.isGroup?o(s(f,n)):n&&o(s(l,!0))}}}}return o(e),c}function te(e,t){const n=e.siblings,r=n.length,{index:s}=e;return t?n[(s-1+r)%r]:s===0?null:n[s-1]}function re(e){return e.parent}function T(e,t={}){const{reverse:n=!1}=t,{children:r}=e;if(r){const{length:s}=r,d=n?s-1:0,i=n?-1:s,c=n?-1:1;for(let o=d;o!==i;o+=c){const l=r[o];if(!l.disabled&&!l.ignored)if(l.isGroup){const h=T(l,t);if(h!==null)return h}else return l}}return null}const ie={getChild(){return this.ignored?null:T(this)},getParent(){const{parent:e}=this;return e!=null&&e.isGroup?e.getParent():e},getNext(e={}){return _(this,"next",e)},getPrev(e={}){return _(this,"prev",e)}};function se(e,t){const n=t?new Set(t):void 0,r=[];function s(d){d.forEach(i=>{r.push(i),!(i.isLeaf||!i.children||i.ignored)&&(i.isGroup||n===void 0||n.has(i.key))&&s(i.children)})}return s(e),r}function ue(e,t){const n=e.key;for(;t;){if(t.key===n)return!0;t=t.parent}return!1}function D(e,t,n,r,s,d=null,i=0){const c=[];return e.forEach((o,l)=>{var h;const f=Object.create(r);if(f.rawNode=o,f.siblings=c,f.level=i,f.index=l,f.isFirstChild=l===0,f.isLastChild=l+1===e.length,f.parent=d,!f.ignored){const m=s(o);Array.isArray(m)&&(f.children=D(m,t,n,r,s,f,i+1))}c.push(f),t.set(f.key,f),n.has(i)||n.set(i,[]),(h=n.get(i))===null||h===void 0||h.push(f)}),c}function le(e,t={}){var n;const r=new Map,s=new Map,{getDisabled:d=W,getIgnored:i=q,getIsGroup:c=H,getKey:o=U}=t,l=(n=t.getChildren)!==null&&n!==void 0?n:j,h=t.ignoreEmptyChildren?u=>{const a=l(u);return Array.isArray(a)?a.length?a:null:a}:l,f=Object.assign({get key(){return o(this.rawNode)},get disabled(){return d(this.rawNode)},get isGroup(){return c(this.rawNode)},get isLeaf(){return R(this.rawNode,h)},get shallowLoaded(){return V(this.rawNode,h)},get ignored(){return i(this.rawNode)},contains(u){return ue(this,u)}},ie),m=D(e,r,s,f,h);function w(u){if(u==null)return null;const a=r.get(u);return a&&!a.isGroup&&!a.ignored?a:null}function g(u){if(u==null)return null;const a=r.get(u);return a&&!a.ignored?a:null}function N(u,a){const p=g(u);return p?p.getPrev(a):null}function v(u,a){const p=g(u);return p?p.getNext(a):null}function A(u){const a=g(u);return a?a.getParent():null}function L(u){const a=g(u);return a?a.getChild():null}const b={treeNodes:m,treeNodeMap:r,levelTreeNodeMap:s,maxLevel:Math.max(...s.keys()),getChildren:h,getFlattenedNodes(u){return se(m,u)},getNode:w,getPrev:N,getNext:v,getParent:A,getChild:L,getFirstAvailableNode(){return ee(m)},getPath(u,a={}){return $(u,a,b)},getCheckedKeys(u,a={}){const{cascade:p=!0,leafOnly:K=!1,checkStrategy:k="all",allowNotLoaded:S=!1}=a;return E({checkedKeys:P(u),indeterminateKeys:x(u),cascade:p,leafOnly:K,checkStrategy:k,allowNotLoaded:S},b)},check(u,a,p={}){const{cascade:K=!0,leafOnly:k=!1,checkStrategy:S="all",allowNotLoaded:y=!1}=p;return E({checkedKeys:P(a),indeterminateKeys:x(a),keysToCheck:u==null?[]:I(u),cascade:K,leafOnly:k,checkStrategy:S,allowNotLoaded:y},b)},uncheck(u,a,p={}){const{cascade:K=!0,leafOnly:k=!1,checkStrategy:S="all",allowNotLoaded:y=!1}=p;return E({checkedKeys:P(a),indeterminateKeys:x(a),keysToUncheck:u==null?[]:I(u),cascade:K,leafOnly:k,checkStrategy:S,allowNotLoaded:y},b)},getNonLeafKeys(u={}){return F(m,u)}};return b}export{le as a,ae as c,se as f};
